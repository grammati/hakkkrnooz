<html><head><link rel="stylesheet" type="text/css" href="http://ycombinator.com/news.css">
<link rel="shortcut icon" href="http://ycombinator.com/favicon.ico">
<script>
function byId(id) {
  return document.getElementById(id);
}

function vote(node) {
  var v = node.id.split(/_/);   // {'up', '123'}
  var item = v[1]; 

  // hide arrows
  byId('up_'   + item).style.visibility = 'hidden';
  byId('down_' + item).style.visibility = 'hidden';

  // ping server
  var ping = new Image();
  ping.src = node.href;

  return false; // cancel browser nav
} </script><title>Lisp as the Maxwell’s equations of software | Hacker News</title></head><body><center><table border=0 cellpadding=0 cellspacing=0 width="85%" bgcolor=#f6f6ef><tr><td bgcolor=#ff6600><table border=0 cellpadding=0 cellspacing=0 width="100%" style="padding:2px"><tr><td style="width:18px;padding-right:4px"><a href="http://ycombinator.com"><img src="http://ycombinator.com/images/y18.gif" width=18 height=18 style="border:1px #ffffff solid;"></img></a></td><td style="line-height:12pt; height:10px;"><span class="pagetop"><b><a href="news">Hacker News</a></b><img src="http://ycombinator.com/images/s.gif" height=1 width=10><a href="newest">new</a> | <a href="newcomments">comments</a> | <a href="ask">ask</a> | <a href="jobs">jobs</a> | <a href="submit">submit</a></span></td><td style="text-align:right;padding-right:4px;"><span class="pagetop"><a href="newslogin?whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">login</a></span></td></tr></table></td></tr><tr style="height:10px"></tr><tr><td><table border=0><tr><td><center><a id=up_3830867 href="vote?for=3830867&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830867></span></center></td><td class="title"><a href="http://www.michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/">Lisp as the Maxwell’s equations of software</a><span class="comhead"> (michaelnielsen.org) </span></td></tr><tr><td colspan=1></td><td class="subtext"><span id=score_3830867>102 points</span> by <a href="user?id=raganwald">raganwald</a> 7 hours ago  | <a href="item?id=3830867">12 comments</a></td></tr><tr style="height:10px"></tr><tr><td></td><td><form method=post action="/r"><input type=hidden name="fnid" value="XAX5iYwJ8b"><textarea name="text" rows=6 cols=60></textarea><br><br>
<input type=submit value="add comment"></form></td></tr></table><br><br>
<table border=0><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3831721 href="vote?for=3831721&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831721></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=drostie">drostie</a> 40 minutes ago  | <a href="item?id=3831721">link</a></span></div><br>
<span class="comment"><font color=#000000>I have a little git project called 'cetis' where I throw cute/dangerous ideas for a next-gen language, and actually the idea of eval/apply as the "Maxwell's equations of software" is in there due to a talk by Gerald Jay Sussman which is transcribed. He says something to this effect: "Look at what these equations say. They say that a changing magnetic field causes a changing electric field, and a changing electric field causes a changing magnetic field. Look at what we have -- eval calls apply, apply calls eval."<p>So, cool, but why not push this metaphor further? That's the dangerous idea.<p>The dangerous idea is that Maxwell's equations don't use voltages. We love voltages. They're useful everywhere. In Einstein's special relativity, once you invent voltages (and their magnetic counterpart, the vector potential) all four Maxwell equations stop being separate, they all take the same form. So you tack the charges ρ onto the current j to get the 4-current Jⁿ = (ρ c, j). You tack the voltage V onto the vector potential a to get the 4-potential Aⁿ = (V/c, a). Then the entire set of Maxwell's equations becomes a single wave equation of your voltages emanating from your currents:<p><pre><code>    ∂ᵢ ∂ⁱ Aⁿ = μ₀ Jⁿ 
</code></pre>
There are four of them, one for every n, but they're all the same form. If you understand one, you understand them all. There are a couple conventions -- these are summed over i, and if you really wanted to know the kinematics you would want to know the fields -- and those are instead:<p><pre><code>    Fᵤᵥ = ∂ᵤ Aᵥ − ∂ᵥ Aᵤ
</code></pre>
The space-to-time components of the field matrix are the electric field, the space-to-other-space components of the F tensor are the magnetic field; the minus sign guarantees that there are no space-to-same-space or time-to-time components; those are all zero.<p>Now, before this becomes a rant, here is the idea. Is there a way in which apply can look like eval, and eval can look like apply? If Einstein is a lesson, we might have to invent a means of programming where you look directly at invariants which you want to create.<p>The goal is that you should just specify an inhomogeneity, a little piece of data and some information on how it should be. The computer then constructs the invariants through some sort of "computational wave" -- and from this the computer can derive the actual field, the instructions needed to actually run the process on a computer.<p>There are some tantalizing suggestions and possibilities. The Meta II compiler (recently extended in JS as the OMeta project, which is definitely on my source-code reading list) works by realizing that a bunch of different stages in compilation are all just the same idea of pattern matching.<p>Perhaps one day we'll do what we do with photomultiplier tubes: we just visualize the voltages that we'd need to focus and accelerate electrons into the metal plates, and not even pay attention to the lower-level picture of how these fields are being generated to do the right thing.</font></span><p><font size=1><u><a href="reply?id=3831721&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3831784 href="vote?for=3831784&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831784></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tete">tete</a> 2 minutes ago  | <a href="item?id=3831784">link</a></span></div><br>
<span class="comment"><font color=#000000>Coincidence. Two days ago stumbled across Racket. Pretty nice, because it's extremely easy to use and supports a number of languages. Just wanted to throw it in for everyone who (like me) always said "sometime". Everything easier than one my think. :)<p><a href="http://racket-lang.org/" rel="nofollow">http://racket-lang.org/</a><p>Oh and for everyone who wants to get into functional programming, very quick (and very hard) simply has to read this Wikibook. It's short, but you will most likely have _understood_ two functional languages (Scheme and Haskell), if you do it seriously:<p><a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours" rel="nofollow">http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_H...</a><p>So Racket for a great (free) time and the latter one for Hackers. At least that's what it looks to me. I just have skimmed through them, but they are the best two things I have found in a while.</font></span><p><font size=1><u><a href="reply?id=3831784&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3831196 href="vote?for=3831196&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831196></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=daniel-cussen">daniel-cussen</a> 4 hours ago  | <a href="item?id=3831196">link</a></span></div><br>
<span class="comment"><font color=#000000>I discovered you can get eval to recognize natural numbers without introducing more primitives if you take the number in binary, enter it into a list, reverse it, and replace the 1's with t's and the 0's with nil's.<p>If you do it that way, you can binary right shift a number by consing a nil at the front, or binary left shift by taking the cdr.  You can increment, decrement, add and subtract efficiently, too.  Even take logarithms.<p>I had to use this to replace Lisp's namesake linked lists with another data structure that allowed many of the same niceties, but required some math, and therefore naturals, to find elements in the data structure.  It was an interesting project.  If you made it through the whole article, you might want to look:<p><a href="http://dcussen.posterous.com/lisp-in-lisp-without-linked-lists" rel="nofollow">http://dcussen.posterous.com/lisp-in-lisp-without-linked-lis...</a></font></span><p><font size=1><u><a href="reply?id=3831196&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3831012 href="vote?for=3831012&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831012></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=guns">guns</a> 6 hours ago  | <a href="item?id=3831012">link</a></span></div><br>
<span class="comment"><font color=#000000>John Shutt's Kernel language [1], decomposes lambda into unevaluated operands, a lexical environment, and the function body:<p><pre><code>    '(λ args body)
</code></pre>
can be expressed as:<p><pre><code>    ($vau args env body) [2]
</code></pre>
Interestingly, because $vau does not evaluate `args` and explicitly recieves a lexical binding, macros are not necessary in Kernel, and hygiene is a simple matter of (eval)ing with the right environment.<p>Arguably then, Kernel is more fundamental than Lisp.<p>[1]: <a href="http://web.cs.wpi.edu/~jshutt/kernel.html" rel="nofollow">http://web.cs.wpi.edu/~jshutt/kernel.html</a><p>[2]: Manuel Simoni has a short overview of $vau here:
<a href="http://axisofeval.blogspot.com/2012/03/i-want-to-understand-vau.html" rel="nofollow">http://axisofeval.blogspot.com/2012/03/i-want-to-understand-...</a></font></span><p><font size=1><u><a href="reply?id=3831012&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3831082 href="vote?for=3831082&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831082></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=akkartik">akkartik</a> 5 hours ago  | <a href="item?id=3831082">link</a></span></div><br>
<span class="comment"><font color=#000000>I think you mean to say that Kernel doesn't need to implement macros because they can be built using <i>$vau</i>.<p>---<p>Besides that, I think you're overstating its significance.<p>a) Maxwell's equations don't claim to be 'most fundamental'. They are a concise basis set for a space of problems. They occupy a memetic sweet spot; abstractions both above and below them are more verbose. The metacircular interpreter of Kernel can't compete with McCarthy's version.<p>b) Any language with fexprs is 'as fundamental' as Kernel. Including LISP 1.<p>c) In its search for hygiene Kernel eliminates <i>quote</i>. Scheme folks will likely find this a useful tradeoff, while common lisp folks with their backquoted macros will shudder. In kernel you 'create macros' by explicitly consing code.</font></span><p><font size=1><u><a href="reply?id=3831082&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3831135 href="vote?for=3831135&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831135></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=guns">guns</a> 5 hours ago  | <a href="item?id=3831135">link</a></span></div><br>
<span class="comment"><font color=#000000>I concede your point about Maxwell's equations. Their historical significance in particular is the unbelievably rich research that ensued from its implications.<p>By this metric, Lisp is obviously the analogue in the programming world. It would have been nice though if Lisp had triggered a sudden paradigm shift instead of this painful 50 year burn we're living through.</font></span><p><font size=1><u><a href="reply?id=3831135&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3831273 href="vote?for=3831273&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831273></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=gruseom">gruseom</a> 4 hours ago  | <a href="item?id=3831273">link</a></span></div><br>
<span class="comment"><font color=#000000>We're still early in the game. 50 years feels like a long time to an individual human but historically it's just a start.</font></span><p><font size=1><u><a href="reply?id=3831273&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3831348 href="vote?for=3831348&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831348></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lispm">lispm</a> 3 hours ago  | <a href="item?id=3831348">link</a></span></div><br>
<span class="comment"><font color=#000000>That beams you right back to the 1960s where FEXPRs were common in Lisp. They died a slow and horrible death at the end of the 70s under the influence of Scheme and Maclisp.</font></span><p><font size=1><u><a href="reply?id=3831348&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3831414 href="vote?for=3831414&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831414></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=akkartik">akkartik</a> 3 hours ago  | <a href="item?id=3831414">link</a></span></div><br>
<span class="comment"><font color=#000000>Kernel makes the point that much of the vilification of fexprs was actually caused by dynamic scope. Combining them with lexical scope makes for a surprisingly reasonable language.</font></span><p><font size=1><u><a href="reply?id=3831414&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3831703 href="vote?for=3831703&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831703></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lispm">lispm</a> 48 minutes ago  | <a href="item?id=3831703">link</a></span></div><br>
<span class="comment"><font color=#000000>That were not the arguments of Pitman.</font></span><p><font size=1><u><a href="reply?id=3831703&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3831167 href="vote?for=3831167&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831167></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=cageface">cageface</a> 5 hours ago  | <a href="item?id=3831167">link</a></span></div><br>
<span class="comment"><font color=#000000>Certainly there's something very intellectually appealing about a completely transparent stack of abstractions in which all the upper layers can be ultimately be expressed in terms of atomic operations.<p>However, I'm not so sure this is really so important in practice. We tend to operate within bounded layers of abstraction for any given problem and it's far more important that those layers are predictable, comprehensible, and, ideally, well-documented.<p>This is why a language like Java, for instance, can be very productive even though the fundamental abstractions are not plastic. And this is also why more malleable languages like Scheme or Lisp can be less productive because there's not enough consensus on how the higher layers should be defined.</font></span><p><font size=1><u><a href="reply?id=3831167&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3831255 href="vote?for=3831255&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3831255></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=fusiongyro">fusiongyro</a> 4 hours ago  | <a href="item?id=3831255">link</a></span></div><br>
<span class="comment"><font color=#000000>I agree, and I think we see this same thing bore out time and again in our field. This is also the distinction between monolithic and microkernels, part of the reason Haskell is succeeding while ML atrophied, the success of statistical AI over "classical" AI, and so forth. We are attracted to minimalism, but it's too much of a hair shirt in practice.</font></span><p><font size=1><u><a href="reply?id=3831255&whence=%69%74%65%6d%3f%69%64%3d%33%38%33%30%38%36%37">reply</a></u></font></td></tr></table></td></tr></table><br><br>
</td></tr><tr><td><img src="http://ycombinator.com/images/s.gif" height=10 width=0><table width="100%" cellspacing=0 cellpadding=1><tr><td bgcolor=#ff6600></td></tr></table><br>
<center><span class="yclinks"><a href="lists">Lists</a> | <a href="rss">RSS</a> | <a href="http://ycombinator.com/bookmarklet.html">Bookmarklet</a> | <a href="http://ycombinator.com/newsguidelines.html">Guidelines</a> | <a href="http://ycombinator.com/newsfaq.html">FAQ</a> | <a href="http://ycombinator.com/newsnews.html">News News</a> | <a href="item?id=363">Feature Requests</a> | <a href="http://ycombinator.com">Y Combinator</a> | <a href="http://ycombinator.com/apply.html">Apply</a> | <a href="http://ycombinator.com/lib.html">Library</a></span><br><br>
<form method=get action="http://www.hnsearch.com/search#request/all">Search: <input type=text name="q" value="" size=17></form><br>
</center></td></tr></table></center></body></html>