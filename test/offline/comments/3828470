<html><head><link rel="stylesheet" type="text/css" href="http://ycombinator.com/news.css">
<link rel="shortcut icon" href="http://ycombinator.com/favicon.ico">
<script>
function byId(id) {
  return document.getElementById(id);
}

function vote(node) {
  var v = node.id.split(/_/);   // {'up', '123'}
  var item = v[1]; 

  // hide arrows
  byId('up_'   + item).style.visibility = 'hidden';
  byId('down_' + item).style.visibility = 'hidden';

  // ping server
  var ping = new Image();
  ping.src = node.href;

  return false; // cancel browser nav
} </script><title>Testing like the TSA | Hacker News</title></head><body><center><table border=0 cellpadding=0 cellspacing=0 width="85%" bgcolor=#f6f6ef><tr><td bgcolor=#ff6600><table border=0 cellpadding=0 cellspacing=0 width="100%" style="padding:2px"><tr><td style="width:18px;padding-right:4px"><a href="http://ycombinator.com"><img src="http://ycombinator.com/images/y18.gif" width=18 height=18 style="border:1px #ffffff solid;"></img></a></td><td style="line-height:12pt; height:10px;"><span class="pagetop"><b><a href="news">Hacker News</a></b><img src="http://ycombinator.com/images/s.gif" height=1 width=10><a href="newest">new</a> | <a href="newcomments">comments</a> | <a href="ask">ask</a> | <a href="jobs">jobs</a> | <a href="submit">submit</a></span></td><td style="text-align:right;padding-right:4px;"><span class="pagetop"><a href="newslogin?whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">login</a></span></td></tr></table></td></tr><tr style="height:10px"></tr><tr><td><table border=0><tr><td><center><a id=up_3828470 href="vote?for=3828470&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828470></span></center></td><td class="title"><a href="http://37signals.com/svn/posts/3159-testing-like-the-tsa">Testing like the TSA</a><span class="comhead"> (37signals.com) </span></td></tr><tr><td colspan=1></td><td class="subtext"><span id=score_3828470>336 points</span> by <a href="user?id=hawke">hawke</a> 17 hours ago  | <a href="item?id=3828470">87 comments</a></td></tr><tr style="height:10px"></tr><tr><td></td><td><form method=post action="/r"><input type=hidden name="fnid" value="WBQox9xhK0"><textarea name="text" rows=6 cols=60></textarea><br><br>
<input type=submit value="add comment"></form></td></tr></table><br><br>
<table border=0><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3829086 href="vote?for=3829086&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829086></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ejames">ejames</a> 15 hours ago  | <a href="item?id=3829086">link</a></span></div><br>
<span class="comment"><font color=#000000>This is why I left Microsoft.  Automated testing was a separate discipline - meaning there were "dev devs" and "test devs".  Automated tests were written based on what the "test devs" had time for, not on the need or usefulness of such tests for the actual code.  I was hired as a "test dev" - I had no industry experience at the time and figured I would give it an unprejudiced try to see if I liked it.<p>I quickly realized that my job was futile - many of the "good" tests had already been written, while in other places, "bad" tests were entrenched and the "test dev" had the job of manning the scanner to check for nail clippers, or upgrading the scanner to find as many nail clippers as possible.<p>Here's a useful rule on the subject that I picked up from an Artificial Intelligence course back in the day:  The value of a piece of information is proportional to the chance that you will act on it times the benefit of acting on it.  We all realize there is no benefit in testing if you ignore failures rather than acting to fix the bugs, but in much the same way that doing nothing when tests fail has no benefit, doing nothing when tests pass also has no benefit - so tests which always pass are just as useless as failing tests you ignore, as are tests which only turn up corner-case bugs that you would have been comfortable with shipping.<p>If you're doing the right amount of testing, there should be a good chance, whenever you kick off a test run, that your actions for the next hour will change depending on the results of the run.  If you typically don't change your actions based on the information from the tests, then the effort spent to write tests gathering that information was wasted.</font></span><p><font size=1><u><a href="reply?id=3829086&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829119 href="vote?for=3829119&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829119></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=SoftwareMaven">SoftwareMaven</a> 15 hours ago  | <a href="item?id=3829119">link</a></span></div><br>
<span class="comment"><font color=#000000>I disagree that there is no benefit in passing tests that don't change your behavior. Those tests are markers to prevent you from unknowingly doing something that should have changed your behavior. That is where the nuance enters: is this a marker I want to lay down or not? Some markers should be there; others absolutely should not and just introduce noise.</font></span><p><font size=1><u><a href="reply?id=3829119&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829213 href="vote?for=3829213&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829213></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ejames">ejames</a> 15 hours ago  | <a href="item?id=3829213">link</a></span></div><br>
<span class="comment"><font color=#000000>I don't understand what you mean by "prevent you from unknowingly doing something that should have changed your behavior".  If you do something without knowing it, how could it change your behavior?  If it's a case where you should have changed your behavior, why would you prevent it?</font></span><p><font size=1><u><a href="reply?id=3829213&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3829299 href="vote?for=3829299&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829299></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=xianshou">xianshou</a> 14 hours ago  | <a href="item?id=3829299">link</a></span></div><br>
<span class="comment"><font color=#000000>I believe the above comment refers to regression testing. For instance, if I write a test for an invariant that is fairly unlikely to change, then the chance that my behavior will change in the next hour based on the test run is small. However, if and when the invariant is mistakenly changed, even though negative side effects might not be immediately visible, it could be immensely valuable to me to see the flaw and restore that invariant.</font></span><p><font size=1><u><a href="reply?id=3829299&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=160></td><td valign=top><center><a id=up_3829395 href="vote?for=3829395&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829395></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ejames">ejames</a> 14 hours ago  | <a href="item?id=3829395">link</a></span></div><br>
<span class="comment"><font color=#000000>Yes - but the test would fail when the invariant is mistakenly changed.  On the test run after the invariant was changed, you would get new information (the test does not always pass) and change your behavior (revert the commit which altered the invariant).<p>That is the point of the "changing behavior" rule - you do not gather the benefit of running a test until it has failed at least once, and the benefit gathered is proportionate to the benefit of the action you take upon seeing the failure.  The tricky part of the rule is that you must predict your actions in the future, since a test that might have a very important failure later could pass all the time right now.  Knowing your own weaknesses and strengths is important, as is knowing the risks of your project.<p>There are possible design benefits to writing tests, since you must write code that is testable, and testable code tends to also be modular.  However, once you have written testable code, you still gain those design benefits even if you never run your test suite, or even delete your tests entirely!</font></span><p><font size=1><u><a href="reply?id=3829395&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=200></td><td valign=top><center><a id=up_3829452 href="vote?for=3829452&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829452></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=SoftwareMaven">SoftwareMaven</a> 14 hours ago  | <a href="item?id=3829452">link</a></span></div><br>
<span class="comment"><font color=#000000>Your comment reads like you can know when a test will fail in the future (how else can you know the difference between a test that "always passes" and a test that will fail in the future to identify a regression?). You may have a test that passes for ten years. When do you know it's OK to nuke the test?<p>Based on your follow-up, it is clear that my reading was not what you intended.</font></span><p><font size=1><u><a href="reply?id=3829452&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=240></td><td valign=top><center><a id=up_3829540 href="vote?for=3829540&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829540></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ejames">ejames</a> 13 hours ago  | <a href="item?id=3829540">link</a></span></div><br>
<span class="comment"><font color=#000000>You can't know, but you can guess, based on past experience or logic.  The simplest way to estimate the future is to guess that it will be similar to the past.<p>For example, if you personally tend to write off-by-one errors a lot, it's a good idea to write tests which check that.  On the other hand, if you almost never write off-by-one errors, you can skip those tests.  If test is cheap to write, easy to investigate, and covers a piece of code that would cause catastrophic problems if it failed, it's worthwhile to write the test even if you can barely imagine a possible situation where it would fail - the degree of the cost matters as much as the degree of the benefit.<p>You don't "know" when it's OK to nuke a test just as you don't really "know" when it's safe to launch a product - you decide what you're doing based on experience, knowledge, and logic.  The important step many don't take is developing the ability to distinguish between good tests and bad tests, rather than simply having an opinion on testing in general.</font></span><p><font size=1><u><a href="reply?id=3829540&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=280></td><td valign=top><center><a id=up_3829874 href="vote?for=3829874&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829874></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=xianshou">xianshou</a> 12 hours ago  | <a href="item?id=3829874">link</a></span></div><br>
<span class="comment"><font color=#000000>Re: "The simplest way to estimate the future is to guess that it will be similar to the past."<p>When we say that the future will be similar to the past, for code, we really mean that the probability of certain events occurring in the future will be similar to their prior probability of occurring in the past.<p>In my hypothetical example of testing an invariant that is unlikely to fail but damaging if it does, it might be valuable to keep that test around for five years even if it never fails. Imagine that the expected frequency of failure was initially &#60;once per ten years&#62;, and that the test hasn't failed after five years. If the expected frequency of failure, cost of failure, and gain from fixing a failure remain the same, we should keep the test even if it's never failed: the expected benefit is constant.<p>Not to say that we should test for every possible bug, but if something is important enough in the first place to test for it, and that doesn't change (as calculated by expected benefit minus expected cost of maintenance), we should keep the test whether or not it changes our behavior.<p>Thus, if we could estimate probabilities correctly, we really would know when it's OK to nuke a test.</font></span><p><font size=1><u><a href="reply?id=3829874&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829562 href="vote?for=3829562&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829562></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=Splines">Splines</a> 13 hours ago  | <a href="item?id=3829562">link</a></span></div><br>
<span class="comment"><font color=#000000>Hey Evan ;)<p>&#62; <i>We all realize there is no benefit in testing if you ignore failures rather than acting to fix the bugs, but in much the same way that doing nothing when tests fail has no benefit, doing nothing when tests pass also has no benefit - so tests which always pass are just as useless as failing tests you ignore, as are tests which only turn up corner-case bugs that you would have been comfortable with shipping.</i><p>On the contrary, my opinion is that we don't see this often enough.  Our bug database shows the current list of defects, and there is very very <i>very</i> little data on what does work.  What is test covering, and how many defects are they finding within that coverage?<p>If your bug trend is heading downward, is it because the test org is distracted by something, or because there are fewer bugs that they are encountering?</font></span><p><font size=1><u><a href="reply?id=3829562&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829935 href="vote?for=3829935&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829935></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ejames">ejames</a> 12 hours ago  | <a href="item?id=3829935">link</a></span></div><br>
<span class="comment"><font color=#000000>Hey Jonathan ;)<p>This is the danger of having a 'test org' separate from the 'dev org'.  When writing tests is tied to writing production code, your progress in one is tied to progress in the other.  If it's easy to write tests for a particular feature, then the developer stops writing tests and writes the feature once they're done with the easy tests.  It's much easier to understand your coverage when you're actually working with and writing the code being covered, rather than working in some separate "test org" - you don't need to run a coverage tool, you just see what breaks if you comment out a chunk of code.  If the answer is "nothing" then it wasn't covered!<p>At the end of the day, an automated test suite is a product for developers on your project in the same way that a car is a product for drivers.  You will have a hard time making a car if nobody on your car-making team can drive, and you will have a hard time writing a test suite as a tool to develop Project Foo if nobody on your test-writing team develops Project Foo.<p>I now write a project where I handle both the code and the tests.  In the same way that my production code is improved by writing tests, my tests are improved by writing production code.  I know what is included in the test coverage in the same way that I know what I had for lunch today - because I was there and I remember what happened.  Tools for checking coverage are an aid to my understanding; in a company with a separate test org, you don't know anything about coverage until you've run the tool.</font></span><p><font size=1><u><a href="reply?id=3829935&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3830131 href="vote?for=3830131&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830131></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=DrJokepu">DrJokepu</a> 11 hours ago  | <a href="item?id=3830131">link</a></span></div><br>
<span class="comment"><font color=#000000>While I agree with this description of the value of information, I disagree with your interpretation of it in this context. Consider the following, rather extreme example: nuclear power stations are equipped with countless diagnostic systems with several levels of fallback. In a well-built and well-operated nuclear power station these systems will never signal failure during normal operation. This clearly doesn't mean that the output of these systems carries little value. Surely, a test that is always passing doesn't necessarily has no benefit, you also have to consider what it would mean if it suddenly stopped passing.</font></span><p><font size=1><u><a href="reply?id=3830131&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3830153 href="vote?for=3830153&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830153></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=run4yourlives">run4yourlives</a> 11 hours ago  | <a href="item?id=3830153">link</a></span></div><br>
<span class="comment"><font color=#000000>You are not designing nuclear power stations. You are at best designing a piece of business software.<p>(If you are designing a life-critical application, the scope of this article doesn't apply to you, as is stated in the article)</font></span><p><font size=1><u><a href="reply?id=3830153&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%39%30%38%36">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829376 href="vote?for=3829376&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829376></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=BadassFractal">BadassFractal</a> 14 hours ago  | <a href="item?id=3829376">link</a></span></div><br>
<span class="comment"><font color=#000000>I worked on enterprise projects "at a similar company" with a few hundred "top notch" engineers. We had no more than 30% coverage, most of it from SDETs. No tests were being written by the devs before checking in for months, the test devs were understaffed, unqualified and thus behind. At one point someone made a checkin that prevented login from happening. Nobody noticed for a full work week, until that version made it into preproduction and someone finally attempted to login. Apparently hundreds of mils spent on the project can't buy you a team able to write above high-school level code.<p>I can see the usefulness of SDETs in doing system / end-to-end testing or testing of really obscure scenarios, but most of the test writing should belong to devs. I love the Rails approach to UT, functional and integration test split. The first time you try BDD, especially if you're coming from an after-the-fact testing culture like the one above, you almost want to cry from joy. I agree that Cucumber might a bit of an overkill, but perhaps I don't get it. For a non-prototypey project you should absolutely add other types horizontal testing like performance, security..</font></span><p><font size=1><u><a href="reply?id=3829376&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3828531 href="vote?for=3828531&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828531></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jashkenas">jashkenas</a> 17 hours ago  | <a href="item?id=3828531">link</a></span></div><br>
<span class="comment"><font color=#000000>A thought that folks reading this post might have an opinion on:<p>"Libraries should be mostly unit tested. Applications should be mostly (and lightly) integration tested. Naturally, some parts of a complex app will behave like a library..."<p>Agree or disagree?</font></span><p><font size=1><u><a href="reply?id=3828531&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828637 href="vote?for=3828637&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828637></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=raganwald">raganwald</a> 17 hours ago  | <a href="item?id=3828637">link</a></span></div><br>
<span class="comment"><font color=#000000>Strongly agree, but also I think that the interesting thing is why this might be so and what it tells us about application architecture.<p>The basic thing about tests is that once you have them passing, they represent statements about constraints on the program. In other words, they express your opinion of things that should not change. Unit tests are a bet that certain aspects of the implementation will not change. Integration tests are a bet that certain aspects of the externally visible behaviour will not change.<p>Libraries tend to be smaller and with well-defined responsibility. Applications tend to be bigger and have many responsibilities. In general, I think it’s true that the requirements for libraries change less often than the requirements for applications. I think this leads us to expect that applications may need to be rewired “under the hood” and have their implementations changed as responsibilities are added, removed, or changed.<p>This, I believe, leads us to want to unit test applications less, because a unit test expresses implementation semantics, and we expect application implementations to change. No what about integration tests? Well, if we’re unit testing less in the application, we need to make up for it by integration testing more, otherwise where do we get our confidence?<p>Now if we throw the words “library” and “application” away, this suggests to me that those parts of the code that are small and tight and with a single, clear responsibility should be unit tested, while those parts that involve a lot of what the AOP people call ‘scattering and tangling,’ should be integration tested.<p>Thoughts?</font></span><p><font size=1><u><a href="reply?id=3828637&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3828725 href="vote?for=3828725&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828725></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> 16 hours ago  | <a href="item?id=3828725">link</a></span></div><br>
<span class="comment"><font color=#000000>Unit testing didn't fully make sense to me until I played around with quickcheck (and eventually theorem proving in Coq). Unit tests vanish nicely to theorems and (empirical) proofs if your code expresses a succinct API. This is one end of the testing continuum.<p>I use this sort of stuff extensively when doing mathematical computing and statistics because there's usually a clear mathematical boundary. Once you're inside it, it's relatively easy to write down global properties (theorems) of your code's API.<p>The moment you cross that boundary your testing apparatuses have to get more complex and your tested properties less well-defined. Unit tests are hazier than quickcheck properties and integration tests hazier still.<p>This continuum seems to be precisely the same as the code reuse continuum. Highly abstracted, testable code with a shapely API is a highly reusable library whether you like it or not. Maybe it's being called by other code, maybe it's being called by your UI, maybe it's being called by the user themselves.</font></span><p><font size=1><u><a href="reply?id=3828725&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3829769 href="vote?for=3829769&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829769></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=Dn_Ab">Dn_Ab</a> 13 hours ago  | <a href="item?id=3829769">link</a></span></div><br>
<span class="comment"><font color=#000000>I view unit tests as a kind of proof by counter-example. You have a logical structure your program embodies. This structure is very hard to specify mathematically and prove deductively so you come up with key statements that must at least evaluate to true for this structure/theory.  The tests are a bunch of counter-examples that should be false (test passed).<p>If a random testing framework is available in your language they really should be integrated as they are able to come up with some pathological examples.</font></span><p><font size=1><u><a href="reply?id=3829769&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%35%33%31">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=160></td><td valign=top><center><a id=up_3829876 href="vote?for=3829876&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829876></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=eru">eru</a> 12 hours ago  | <a href="item?id=3829876">link</a></span></div><br>
<span class="comment"><font color=#000000>For Haskell you can do even better than random testing: There's Lazy SmallCheck for exhaustive testing.  (For some values of `better' and `exhaustive'.)</font></span><p><font size=1><u><a href="reply?id=3829876&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3828697 href="vote?for=3828697&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828697></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=zmoazeni">zmoazeni</a> 16 hours ago  | <a href="item?id=3828697">link</a></span></div><br>
<span class="comment"><font color=#000000>After playing with a language with a great type system (Haskell, not Java/C++), I've become more wary and borderline uncertain about my Ruby code.<p>My integration tests serve two purposes:<p>1) Runs the code in an repeatable and isolated environment to verify I didn't do anything stupid like misname a variable, or treat something nil as an object.<p>2) Validate my unique application logic.<p>I don't think #2 goes away with other languages, but #1 changes dramatically. I've written Ruby for years, so this isn't an "outsider looking in" opinion.<p>Whether conscious or not, I believe move Rubyists gravitate to testing because of both #1 and #2.<p>#2 can be satisfied with unit tests, but in my experience, the suite becomes a lot more flexible when validating it in terms of integration tests.</font></span><p><font size=1><u><a href="reply?id=3828697&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%35%33%31">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3829890 href="vote?for=3829890&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829890></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=MBlume">MBlume</a> 12 hours ago  | <a href="item?id=3829890">link</a></span></div><br>
<span class="comment"><font color=#000000>Note that, at least in python (which I assume is pretty similar to Ruby in ecosystem), you can get a lot of mileage for #1 by doing static analysis, for example Pylint.</font></span><p><font size=1><u><a href="reply?id=3829890&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%35%33%31">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829158 href="vote?for=3829158&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829158></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=MaysonL">MaysonL</a> 15 hours ago  | <a href="item?id=3829158">link</a></span></div><br>
<span class="comment"><font color=#000000>On this, I tend to think that many (most?) libraries, especially where they don't have extreme performance requirements, should have run-time testing. I.e., pre- and post-condition checks, or contracts.</font></span><p><font size=1><u><a href="reply?id=3829158&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829002 href="vote?for=3829002&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829002></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=chrisdinn">chrisdinn</a> 15 hours ago  | <a href="item?id=3829002">link</a></span></div><br>
<span class="comment"><font color=#000000>Agree, but I'm concerned all these rules of thumb are doing nothing to help the authors of bad test suites understand why they're bad and how to fix them.<p>In my opinion the point of building out a test suite isn't to reach 100% code coverage, it's to allow developers working on the application the ability to refactor quickly and aggressively during the development process while remaining confident that it will still perform correctly when they're ready to release. Poorly written tests (or over-testing) will slow down refactoring and hinder development. But, in my experience, not having the right tests can mean firing up your application and manually testing after each small code change to prevent regression. Understanding the trade-off is key to helping developers answer the ubiquitous question: "do I need to test this"?<p>This role for unit tests is described effectively in Chapter 1 of Martin Fowler's awesome Refactoring book (or Refactoring, Ruby Edition, if that suites you. That's the version that's on my desk right now.) This use case is also highlighted in Eric Evans' book Domain Driven Design, where he highlights one of my favourite application development techniques: "refactoring to deeper insight." Both books are among my favourites.<p>Adding features to an application isn't just about appending files and lines of code, it's also about changing existing code to allow the new features to fit comfortably into the application's domain model. If you can accomplish that goal with "light integration tests" go for it. That'll mean much less overhead during refactoring and will do a good job of enforcing correctness. If your application contains a robust domain model (which it very well might) you may find unit tests useful for maintaining model integrity during development. This is probably what's meant by "Naturally, some parts of a complex app will behave like a library". When you change the domain model you'll have to change tests for all the affected classes and that's a good thing. It explicitly highlights how your change affected the model, which you should certainly understand before committing your changes.<p>I will admit this distinction is hard to communicate to first-time TDDers. However, I've found that after having to eat their own dog food for a few iterations (adding features to your own code) smart developers quickly find the sweet spot. The less code you write, the less you have to maintain. But too few test or poorly written tests can slow you down just as much.</font></span><p><font size=1><u><a href="reply?id=3829002&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828608 href="vote?for=3828608&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828608></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=awj">awj</a> 17 hours ago  | <a href="item?id=3828608">link</a></span></div><br>
<span class="comment"><font color=#000000>That sounds good, with the caveat that most applications should have their business logic roughly organized into libraries. After those libraries get their unit tests, integration testing the application&#60;-&#62;library barrier makes a lot of sense.</font></span><p><font size=1><u><a href="reply?id=3828608&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829182 href="vote?for=3829182&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829182></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=angersock">angersock</a> 15 hours ago  | <a href="item?id=3829182">link</a></span></div><br>
<span class="comment"><font color=#000000>We recently finished approximately one metric fuckton of unit tests for the next release of some of our libraries, and I tend to agree very strongly that a library <i>must</i> be well-tested.<p>A problem that we ran into, though, is exactly what to test. The biggest basic distinction we ran into was testing to verify interface integrity (i.e., does this do what it says in the header documentation, pursuant to declared constraints and so on) as opposed to implementation integrity (does my ringbuffer properly move around elements, does my array resize move my elements, etc.).<p>The former is very useful to ensure that the library is good for users, the latter of course is much better for testing that changes to the containers don't do something stupid.</font></span><p><font size=1><u><a href="reply?id=3829182&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828760 href="vote?for=3828760&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828760></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=thmzlt">thmzlt</a> 16 hours ago  | <a href="item?id=3828760">link</a></span></div><br>
<span class="comment"><font color=#000000>100% agreed. Rails people have started to complain about difficult/slow tests because Rails (a framework, not  a library) makes your life hard. From my own experience, you don't need all the Rails magic to get started on a project, and once you do, it just happens to be a completely different magic that you need.<p>Hence I try to divide my projects into lots of application agnostic code (the libraries that need to be unit tested), and little application specific code (the glue code that needs to be integration tested).</font></span><p><font size=1><u><a href="reply?id=3828760&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829568 href="vote?for=3829568&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829568></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jrockway">jrockway</a> 13 hours ago  | <a href="item?id=3829568">link</a></span></div><br>
<span class="comment"><font color=#000000>Apps are libraries with a script somewhere that runs:<p><pre><code>  $container-&#62;build('app')-&#62;run;</code></pre></font></span><p><font size=1><u><a href="reply?id=3829568&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829608 href="vote?for=3829608&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829608></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=bradley-holt">bradley-holt</a> 13 hours ago  | <a href="item?id=3829608">link</a></span></div><br>
<span class="comment"><font color=#000000>Disagree. Your domain model is within the scope of your application. The code representing your domain model should be unit tested. If your application is doing anything interesting then the code for your domain model is the most important thing to test in your application.</font></span><p><font size=1><u><a href="reply?id=3829608&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828642 href="vote?for=3828642&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828642></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tlear">tlear</a> 17 hours ago  | <a href="item?id=3828642">link</a></span></div><br>
<span class="comment"><font color=#000000>It does sound right, where is this quote from?</font></span><p><font size=1><u><a href="reply?id=3828642&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3828674 href="vote?for=3828674&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828674></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jashkenas">jashkenas</a> 16 hours ago  | <a href="item?id=3828674">link</a></span></div><br>
<span class="comment"><font color=#000000>Oh, it's not a quote -- I was just trying to find the most concise way of saying it.</font></span><p><font size=1><u><a href="reply?id=3828674&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828736 href="vote?for=3828736&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828736></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=michaelfeathers">michaelfeathers</a> 16 hours ago  | <a href="item?id=3828736">link</a></span></div><br>
<span class="comment"><font color=#000000>All I can say is that it's an idea. It's a shame there's no rationale.<p>I've seen teams that aggressively put all non-glue code in libraries, but I don't think that is what is meant here.</font></span><p><font size=1><u><a href="reply?id=3828736&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829446 href="vote?for=3829446&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829446></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=stonemetal">stonemetal</a> 14 hours ago  | <a href="item?id=3829446">link</a></span></div><br>
<span class="comment"><font color=#000000>I am not sure I understand the point of making code into a library if it isn't going to be reused outside of the application.  YAGNI and all that.<p>I would agree with unit test logic, integration test glue, but that is heading into truism country.</font></span><p><font size=1><u><a href="reply?id=3829446&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828675 href="vote?for=3828675&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828675></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=quartzmo">quartzmo</a> 16 hours ago  | <a href="item?id=3828675">link</a></span></div><br>
<span class="comment"><font color=#000000>Agree, though following this would lead me to extract all kinds of implicit library code from my applications. Likely not worth the effort without a genuine reuse story.</font></span><p><font size=1><u><a href="reply?id=3828675&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3829082 href="vote?for=3829082&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829082></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=damoncali">damoncali</a> 15 hours ago  | <a href="item?id=3829082">link</a></span></div><br>
<span class="comment"><font color=#000000><i>Don’t use Cucumber...</i><p>Thank God someone with a bullhorn finally said this. I was beginning to think I was alone in my hatred of Cucumber. (And my love of Test:Unit/Minitest.)</font></span><p><font size=1><u><a href="reply?id=3829082&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829703 href="vote?for=3829703&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829703></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=davidw">davidw</a> 13 hours ago  | <a href="item?id=3829703">link</a></span></div><br>
<span class="comment"><font color=#000000>When I saw the whole "looks like English!" thing I skipped it without a second thought.  That's just a bad idea because you're going to piss people off when it turns out that it's really nothing at all like English, and you're also going to irritate the people who wonder why Ruby constructs don't work either.</font></span><p><font size=1><u><a href="reply?id=3829703&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3830706 href="vote?for=3830706&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830706></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=sciurus">sciurus</a> 8 hours ago  | <a href="item?id=3830706">link</a></span></div><br>
<span class="comment"><font color=#000000>A relevant blog post - <a href="http://www.jackkinsella.ie/2011/09/26/why-bother-with-cucumber-testing.html" rel="nofollow">http://www.jackkinsella.ie/2011/09/26/why-bother-with-cucumb...</a></font></span><p><font size=1><u><a href="reply?id=3830706&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829294 href="vote?for=3829294&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829294></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=typicalrunt">typicalrunt</a> 14 hours ago  | <a href="item?id=3829294">link</a></span></div><br>
<span class="comment"><font color=#000000>I'm in the same boat as you, but I don't tend to voice my opinions on Test::Unit because there is such a strong opinion <i>for</i> RSpec and Cucumber.  IMHO, I tend to like my tools to be tried and true, and not do any fancy magic.</font></span><p><font size=1><u><a href="reply?id=3829294&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829510 href="vote?for=3829510&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829510></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=equalarrow">equalarrow</a> 14 hours ago  | <a href="item?id=3829510">link</a></span></div><br>
<span class="comment"><font color=#000000>Learned my lesson the hard way(s) with Rspec and Cucumber a while ago - total waste of my time.<p>There's a group of devs that have fooled themselves into thinking anyone outside their group understands how they are testing. I've seen this firsthand. DHH has always been right, imo, in this regard; test what you think is important, use simple tools.<p>TestUnit still serves me well and it perfectly fits my needs of do more with less.</font></span><p><font size=1><u><a href="reply?id=3829510&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3830030 href="vote?for=3830030&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830030></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=PatrickTulskie">PatrickTulskie</a> 11 hours ago  | <a href="item?id=3830030">link</a></span></div><br>
<span class="comment"><font color=#000000>I used Test::Unit for a long time, but I found it to be a poor tool when doing integration tests.  RSpec lets me do both within the same DSL quite easily.  That's probably why a lot of people flock to RSpec.  I still have old Test::Unit code sitting in my RSpec suite that I haven't moved over to RSpec's DSL.<p>That being said, to a developer writing tests and doing TDD, Cucumber is a speed bump that doesn't need to be there.  RSpec is great without lumping more crap on top of it.</font></span><p><font size=1><u><a href="reply?id=3830030&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3828841 href="vote?for=3828841&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828841></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=skrebbel">skrebbel</a> 16 hours ago  | <a href="item?id=3828841">link</a></span></div><br>
<span class="comment"><font color=#000000>Nice read.<p>I'm no Rails dev, so I'm curious about this one point from DHH:<p>&#62; <i>6. Don't use Cucumber unless you live in the magic kingdom of non-programmers-writing-tests (and send me a bottle of fairy dust if you're there!)</i><p>I mostly do C#, and teams I've recently been on have found SpecFlow tests to be an <i>excellent</i> time saver in communicating requirements and acceptance test criteria with customers. Has Cucumber not been designed for the same purpose?<p>I might guess that David included the point because a product business such as 37signals has no non-programming stakeholders to communicate about requirements and acceptance criteria with.<p>Using BDD for having non-programmers <i>write</i> tests sounds far-fetched to me indeed. It's excellent to have them able to <i>read and understand</i> the tests, though. Any opinions? Is BDD as dead horse, or is DHH a little narrow minded here?</font></span><p><font size=1><u><a href="reply?id=3828841&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829062 href="vote?for=3829062&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829062></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=damoncali">damoncali</a> 15 hours ago  | <a href="item?id=3829062">link</a></span></div><br>
<span class="comment"><font color=#000000>My own observation is that some ruby/rails developers get so enthralled with testing that it becomes an obsession that eclipses the product that they are building. The result (strong opinion coming...) is libraries like rspec and cucumber. They're complex and burdensome, and tend to attempt to mimic english, but often do so poorly and are totally unsuitable for non-coders. You spend a lot of time learning "the way" to do things and wind up with code that is unintelligible to less experienced developers.<p>I use test::unit and minitest and it gets the job done without having to keep up with the latest trends. It's simple and can be written in a way that correlates well to actual English requirements. It takes all of an hour to digest minitest from zero.<p>That said, Cucumber and rspec are very popular, so I may be the weird one.</font></span><p><font size=1><u><a href="reply?id=3829062&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829459 href="vote?for=3829459&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829459></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=100k">100k</a> 14 hours ago  | <a href="item?id=3829459">link</a></span></div><br>
<span class="comment"><font color=#000000>For a long time, I had a deep hatred for RSpec because we used it on a project before the API stabilized (and before it was easy to maintain an environment where all developers had the same gems).<p>We got stuck on some particular revision in the RSpec Subversion repository. The choice was re-write all the specs, or stick with that ancient version. We re-wrote all the specs -- to test/unit.<p>Several years later, and I have never picked up RSpec for my own use. However, I am working on another project that chose RSpec and it is working out pretty well. I have turned on render_views so I don't have to test those separately and am only using mocking for external services.<p>Cucumber, on the other hand, I do not understand at all. Why write tests in English when you have Ruby?</font></span><p><font size=1><u><a href="reply?id=3829459&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3830960 href="vote?for=3830960&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830960></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=homosaur">homosaur</a> 6 hours ago  | <a href="item?id=3830960">link</a></span></div><br>
<span class="comment"><font color=#000000>There's a few solid reasons I've heard for using Cucumber, although in my life I've not found a need for it yet.<p>1) Although it's a Ruby tool, it works with a ton of languages. Someone can write code based off Cuke tests in Ruby or .NET or whatever without much trouble.<p>2) it makes web workflow testing cake<p>3) it keeps people strongly out of the "implementation" zone when they are thinking about how a program should be properly executed<p>4) it works with many spoken languages so if you're collaborating with an international team it could be useful there.<p>5) it has a whole bunch of report formats built in<p>If you don't find any of those features incredibly useful, I'm not sure you're going to ever see a need for it. I've played with it but for me it seems more hassle than anything. I do LIKE it but that's not enough to justify the time spent messing with it.</font></span><p><font size=1><u><a href="reply?id=3830960&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829336 href="vote?for=3829336&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829336></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=xianshou">xianshou</a> 14 hours ago  | <a href="item?id=3829336">link</a></span></div><br>
<span class="comment"><font color=#000000>Personally, I don't like Cucumber because it attempts to bridge the worlds of development and business but ends up serving neither very well. Its syntax gives it the verbosity of English while removing none of the brittleness of the underlying code. A non-programmer editing tests would need to learn Ruby to deal with the leaks in the abstraction, while a coder is better off describing behavior directly in rspec or Capybara rather than wrapping it in a "story" that should have been a two-line comment.<p>As for non-programmers reading tests, they could read the comments or README.md instead. Why force the documentation to test, and the test to document, if it decreases the efficiency of both?</font></span><p><font size=1><u><a href="reply?id=3829336&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3829698 href="vote?for=3829698&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829698></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=skrebbel">skrebbel</a> 13 hours ago  | <a href="item?id=3829698">link</a></span></div><br>
<span class="comment"><font color=#000000>Genuine interest: how does one use "comments and README.md" for agreeing a set of requirements with stakeholders who are not programmers, yet domain experts?<p>Note, I'm not talking about your average "look, a fancy dropdown control on Github" type of project. I rather mean the "look, it's the entire software stack of a TV" or the "hey, this software computes taxes for all households in a country" type of thing.<p>The stakeholders in such domains typically know quite well what they want, in terms of their domain. The software people know how to turn that into working, maintainable and usable software. Getting the automated tests to also be the acceptance test spec saves a lot of double work, and, most importantly, a lot of human error (acceptance spec not matching acceptance test done, etc).</font></span><p><font size=1><u><a href="reply?id=3829698&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3829031 href="vote?for=3829031&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3829031></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=adrianhoward">adrianhoward</a> 15 hours ago  | <a href="item?id=3829031">link</a></span></div><br>
<span class="comment"><font color=#000000><i>Using BDD for having non-programmers write tests sounds far-fetched to me indeed. It's excellent to have them able to read and understand the tests, though. Any opinions? Is BDD as dead horse, or is DHH a little narrow minded here?</i><p>I thought what you thought - that this is DHH's working context speaking. For me Cuke-ish tests are about alignment and communication - not about  having non-developers write tests.<p>(of course Cucumber isn't the only route for doing that)</font></span><p><font size=1><u><a href="reply?id=3829031&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3828657 href="vote?for=3828657&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828657></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=pbiggar">pbiggar</a> 16 hours ago  | <a href="item?id=3828657">link</a></span></div><br>
<span class="comment"><font color=#000000>I largely agree -  there is a certain testing dogma that goes into testing that this article dispels nicely. Of course, it comes with its own dogma, though I guess that's a bit tongue in cheek considering the author says: "let me firebomb the debate with the following list of nuance-less opinions".<p>So let me add some nuances:<p>1) DO aim high though, just recognize that the work in getting there is probably better spent elsewhere in your app.<p>3) BUT ignore this advice if you don't write tests yet. When you learn to test, or start working on a new feature that you may not know how to test, it will take you as long to test it as to code it. From there on though, test cost of testing is pretty cheap, so the 1/2 or 1/3 ratios start to make sense.<p>4) Do test that you are correctly using features and libraries (yes, standard activerecord stuff is probably going overboard).<p>5) But dont forget that many bugs occur at the boundaries of functional units.<p>6) Do what works for you, and what makes sense for you code base and business priorities. I don't love cucumber myself, but when others swear by it I can see why they like it.<p>Kent Beck's quote at the end is lovely. The first and only book on TDD I read was Beck's, and it's good to know that he's not actually as dogmatic as the book makes you think.</font></span><p><font size=1><u><a href="reply?id=3828657&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=0></td><td valign=top><center><a id=up_3828621 href="vote?for=3828621&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828621></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=astral303">astral303</a> 17 hours ago  | <a href="item?id=3828621">link</a></span></div><br>
<span class="comment"><font color=#000000>Brilliant article. Testing for testings sake is wrong. Testing for 100% coverage sake is wrong. Write just enough tests at the level where it catches most of your regressions. Drill down into unit tests for complex logic, because you can test that more extensively and much faster than an integration test. Then leave a case or two for an integration test to make sure things are hooked up right.<p>Don't be afraid to unit test little complex things here and there. Are you writing a function to parse a string in a certain way? Pick that function, elevate its visibility if need be, write a simple unit test to make sure you didn't make a stupid off-by-one mistake. Does the rest of the class otherwise not loan itself to unit testing? That's OK, move on.<p>We've learned that each line of code is a liability, even if it's a configuration file, which is why we have come to appreciate things like DRY, convention over configuration, less verbose languages, less verbose APIs. Likewise, each line of test code is a liability, so each line better justify itself.</font></span><p><font size=1><u><a href="reply?id=3828621&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=40></td><td valign=top><center><a id=up_3828801 href="vote?for=3828801&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828801></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=stcredzero">stcredzero</a> 16 hours ago  | <a href="item?id=3828801">link</a></span></div><br>
<span class="comment"><font color=#000000><i>Write just enough tests at the level where it catches most of your regressions...make sure you didn't make a stupid off-by-one mistake.</i><p>One thing that I've seen in inexperienced coders (including myself in the past) is that they tend to think of every bug as a fluke one-off mistake in an otherwise mostly flawless and awesome record. New coders tend to want to just fix a bug, then pretend it didn't happen.<p>This is exactly the wrong attitude to take. As a discipline, we programmers should be studying our mistakes and taking steps to prevent them in the future. As a craftsperson striving to improve, each of us should be studying our own mistakes and taking steps to prevent them in the future.</font></span><p><font size=1><u><a href="reply?id=3828801&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=80></td><td valign=top><center><a id=up_3828831 href="vote?for=3828831&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3828831></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=astral303">astral303</a> 16 hours ago  | <a href="item?id=3828831">link</a></span></div><br>
<span class="comment"><font color=#000000>I think you might be misreading what I wrote. While your points are correct, I was specifically referring to "off-by-one mistake", which is a common "silly" error (since many indices are zero-based, it's often easy to request one too many elements, or chop off the first item).<p>Also the way you quoted me above, "make sure you didn't make a stupid off-by-one mistake" looks like it's talking about writing just enough tests. However, in context, I'm actually referring to writing unit tests for small items where you might make a stupid off-by-one mistake.<p>So I was never referring to "one-off mistakes", as in mistakes that are flukes.<p>Your points are all good otherwise! Never rest on your laurels and always think about what you can do to catch your mistakes.</font></span><p><font size=1><u><a href="reply?id=3828831&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr><td><table border=0><tr><td><img src="http://ycombinator.com/images/s.gif" height=1 width=120></td><td valign=top><center><a id=up_3830091 href="vote?for=3830091&dir=up&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30"><img src="http://ycombinator.com/images/grayarrow.gif" border=0 vspace=3 hspace=2></a><span id=down_3830091></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=stcredzero">stcredzero</a> 11 hours ago  | <a href="item?id=3830091">link</a></span></div><br>
<span class="comment"><font color=#000000>I did misread what you wrote, but I thought the point was a good one to make, so posted it anyhow. Not disagreeing, just adding.</font></span><p><font size=1><u><a href="reply?id=3830091&whence=%69%74%65%6d%3f%69%64%3d%33%38%32%38%34%37%30">reply</a></u></font></td></tr></table></td></tr><tr style="height:10px"></tr><tr><td class="title"><a href="/x?fnid=N6jfAV7S3N" rel="nofollow">More</a></td></tr></table><br><br>
</td></tr><tr><td><img src="http://ycombinator.com/images/s.gif" height=10 width=0><table width="100%" cellspacing=0 cellpadding=1><tr><td bgcolor=#ff6600></td></tr></table><br>
<center><span class="yclinks"><a href="lists">Lists</a> | <a href="rss">RSS</a> | <a href="http://ycombinator.com/bookmarklet.html">Bookmarklet</a> | <a href="http://ycombinator.com/newsguidelines.html">Guidelines</a> | <a href="http://ycombinator.com/newsfaq.html">FAQ</a> | <a href="http://ycombinator.com/newsnews.html">News News</a> | <a href="item?id=363">Feature Requests</a> | <a href="http://ycombinator.com">Y Combinator</a> | <a href="http://ycombinator.com/apply.html">Apply</a> | <a href="http://ycombinator.com/lib.html">Library</a></span><br><br>
<form method=get action="http://www.hnsearch.com/search#request/all">Search: <input type=text name="q" value="" size=17></form><br>
</center></td></tr></table></center></body></html>